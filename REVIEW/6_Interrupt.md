# 6. 인터럽트의 동작  
>**<목차>**  
>6.1 인터럽트 개요  
>6.2 ATmega128의 인터럽트 구성  
>6.3 ATmega128의 외부 인터럽트  
>6.4 ATmega128의 인터럽트 처리  
>6.5 CodeVision 환경에서의 인터럽트 서비스 루틴의 작성  
>6.6 인터럽트를 이용한 실험  
<br>

## 6.1 인터럽트 개요  
### 인터럽트 개념  
- 프로그램이 수행되고 있는 동안에 어떤 조건이 발생하여 수행중인 프로그램을 일시적으로 중지시키게 만드는 조건이나 사건의 발생  
  + 비동기적으로 처리 --> 다른 프로그램이 수행되는 동안 여러 개의 사건을 처리할 수 있는 메커니즘  
  + 인터럽트가 발생하면 마이크로 컨트롤러는 현재 수행중인 프로그램을 일시 중단하고, 인터럽트 처리를 위한 프로그램을 수행한 후에 다시 원래의 프로그램으로 복귀  
- ISR(Interrupt Service Routine) : 인터럽트 처리하는 프로그램  
- 인터럽트가 발생할 때 주 프로그램은 *일시적으로 정지* 하고 ISR로 분기
- ISR이 실행되고 연산이 수행된 후에 ISR 프로그램이 종료되면, 주 프로그램의 중지된 부분부터 다시 수행 
- 인터럽트의 종료는 RETI(return from interrupt) 명령에 의해 수행
- Background Process/Foreground Process  

### 인터럽트의종류  
- 인터럽트 발생 원인에 의한 분류    
  + 하드웨어 인터럽트  
    * 내부 인터럽트 : 마이크로 컨트롤러 내부의 기능에 의해 발생   
    * 외부 인터럽트 : 마이크로 컨트롤러 외부에 부가된 소자에 의해 발생  
  + 소프트웨어 인터럽트  
- 인터럽트 처리 방식에 의한 분류 
  + 일반적인 인터럽트 (\INT)
    * 프로그램에 의하여 인터럽트의 요청을 받아들이지 않고 무시할 수 있는 구조의 인터럽트(maskable interrupt)
    * 우선처리 메커니즘 
    * 우선처리 메커니즘의 경우 보통 인터럽트를 허용하는 방법은 인터럽트 마스크 레지스터 또는 인터럽트 허용 레지스터를 사용하여 각각의 인터럽트를 개별적으로 허용하고 이것들을 다시 전체적으로 허용함
  + 차단 불가능 인터럽트 (\NMI)
    * 프로그램에 의해 어떤 방법으로도 인터럽트 요청이 차단될 수 없는 인터럽트 (non-maskable interrupt)
    * 시스템에 치명적인 오류를 대비하기 위해 사용  

### 인터럽트의 제어 및 처리 절차  
- 벡터형 인터럽트
  + 인터럽트가 발생할 때마다 인터럽트를 요청한 장치가 인터럽트 벡터를 마이크로컨트롤러에게 전송하는 방식
  + 각 주변장치가 각각의 인터럽트 신호선을 가지고 있고, 각 주변장치가 인터럽트를 요청하면 마이크로컨트롤러는 각각의 인터럽트에 따라 미리 지정된 인터럽트 벡터를 가지고 있어 즉시 해당 ISR을 찾아가는 방식     
    * 인터럽트 처리 응답시간이 빠르고, **AVR에 구현된 방식**
 - 인터럽트의 우선순위
   + 2개 이상의 주변장치가 동시에 마이크로컨트롤러에 인터럽트를 요구하는 경우 우선순위를 미리 정하여 한번에 하나의 인터럽트를 선택하여 처리  
   + 우선순위가 높은 인터럽트의 처리 중 -> 낮은 순위의 인터럽트는 대기상태
   + 우선순위가 높은 인터럽트의 처리 끝 -> 낮은 순위의 인터럽트는 **미리 지정된 우선순위**에 의해 처리
     * AVR 에서의 인터럽트 처리의 우선 순위는 벡터테이블에 의해 정의된 순서임

<br>

## 6.2 ATmega128의 인터럽트 구성  
- 인터럽트의 종류
  + 리셋 포함 총 35종의 인터럽트 소스
    * 외부 인터럽트 8개
    * 타이머/카운터0에 관련된 인터럽트 2개
    * 타이머/카운터1에 관련된 인터럽트 5개
    * 타이머/카운터2에 관련된 인터럽트 2개
    * 타이머/카운터3에 관련된 인터럽트 5개
    * USART0와 USART1에 관련된 인터럽트 각각 3개, 기타 인터럽트 6개
  + 인터럽트의 동작 형태 
    * 인터럽트가 발생하면 관련 플래그 비트를 1로 세트하여 트리거 시키는 형태  
      > 프로그램 카운터가 실제 인터럽트 벡터로 지정되어 인터럽트 처리 루틴을 수행
      > 해당 플래그는 하드웨어에 의해 자동으로 0으로 클리어됨.
      > 인터럽트 플래그는 해당 비트에 1을 써넣음으로써 0으로 클리어 가능
      > 인터럽트 마스크 레지스터 또는 SREG 레지스터를 통해 금지 상태로 설정했더라도 인터럽트 발생 시 해당 인터럽트 플래그가 1로 설정되어 인터럽트 대기 상태로 되며, 나중에 인터럽트가 허가상태로 설정될 때 해당 인터럽트가 처리됨
      
- 리셋 및 인터럽트 벡터의 배치  

| BOOTRST | IVSEL | 리셋 벡터 주소 | 인터럽트 벡터의 시작 주소 |  
|:----:|:-----:|:-----:|:------:|
|1|0|0x0000|0x0000|
|1|1|0x0000|부트 리셋 주소 + 0x0002|
|0|0|부트 리셋 주소|0x0002|
|0|1|부트 리셋 주소|부트 리셋 주소 + 0x0002|  
-    
  + 리셋 및 인터럽트 벡터는 BOOTRST와 IVSEL 비트의 조합에 의해 가변적으로 배치
    * 부트 리셋 주소 : 부트 로더 섹션의 크기의 설정에 따라 달라짐.  
    * 일반적인 ATmega128에서는 BOOTRST 비트는 1로 설정되고, IVSEL은 0으로 설정  

- 인터럽트 벡터의 배치  
  + 인터럽트 벡터를 응용 프로그램 섹션과 부트 로더 섹션 사이에서 이동하기 위해서는 MCU 컨트롤 레지스터 (MCUCR) 를 사용
  + MCUCR의 비트 구성은 아래와 같으며, 여기서 IVSEL과 IVCE 비트가 이러한 목적으로 사용되고, 나머지는 외부 인터럽트를 개별적으로 허가하는 용도로 사용  
  + ![image](https://user-images.githubusercontent.com/72501562/121778027-ed030900-cbcf-11eb-9b69-d387167a1907.png)  
    * IVSEL과 IVCE 비트를 사용
    * IVSEL (Interrupt Vector SELect, 인터럽트 벡터 선택)  
      - IVSEL = 0 : 인터럽트 벡터는 응용프로그램 섹션인 플래시 메모리의 시작 부분에 위치  
      - IVSEL = 1 : 인터럽트 벡터는 부트로더 섹션의 시작 부분에 위치  

<br>

## 6.3 ATmega128의 외부 인터럽트  
- 외부 인터럽트의 개요  
  + 8개의 외부 인터럽트 입력 : INT0~7  
    * 상승/하강 에지 및 LOW 상태에 의해 인터럽트 발생
    * 외부 인터럽트의 트리거 방법은 EICRA(INT3~0)와 EICRB(INT7~4)에 의해 결정
  + **레벨 변화** 방식 : 해당 핀에 LOW 상태가 유지되는 동안에 인터럽트 발생 **(비동기적)**
  + **에지 트리거** 방식 : I/O클럭에 **동기**를 맞추어 인터럽트가 발생
  + INT7~4 인터럽트가 **에지 트리거** 방식에 의해 설정되면 이는 I/O 클럭을 필요로 하므로 이것들은 I/O 클럭이 차단되는 휴면 모드 이외의 슬립 모드에서는 슬립 모드를 해제하는 수단으로 사용할 수 없음
  + 모든 LOW레벨 인터럽트와 INT3~0 인터럽트가 하강 또는 상승 에지 트리거 방식으로 설정된 경우에는 인터럽트가 클럭에 상관없이 비동기적으로 검출되므로 슬립모드를 해제하는 수단으로 사용할 수 있음
  + **레벨 변화** 방식으로 사용되는 인터럽트가 전원 차단 모드의 해제 수단으로 사용되는 경우에는 좀 더 긴 인터럽트 신호가 요구됨. -> 슬립 모드를 해제하고 인터럽트가 발생되려면 충분히 긴 시간동안 인터럽트 신호가 L 상태로 입력되어야 함.
  + *트리거 : 총의 방아쇠를 의미하며, 어느 특정한 동작에 반응해 자동으로 필요한 동작을 실행하는 것 *  

<br>

- 외부 인터럽트 제어 레지스터  

|외부 인터럽트 레지스터|설명|  |
|:--:|:--:|:--:|
|EIMSK|외부 인터럽트 마스크 레지스터|인터럽트 허가|
|EIFR|외부 인터럽트 플래그 레지스터|인터럽트 발생여부|
|EICRA|외부 인터럽트 트리거 방식 설정 레지스터 (INT0~3)|트리거 방식|
|EICRB|외부 인터럽트 트리거 방식 설정 레지스터 (INT4~7)|트리거 방식|    

<br>

- EIMSK 제어 레지스터  
  + 외부 인터럽트 마스크 레지스터 **EIMSK (External Interrupt MaSK register)**는 인터럽트 INT7~0을 개별적으로 **허가**하는데 사용
    * 1로 설정 시 : 인터럽트 허용
    * 0으로 설정 시 : 인터럽트 금지 <SREG레지스터의 글로벌 인터럽트 허용 비트 I가 1로 되어야만 실제 허용 가능>
    * ![image](https://user-images.githubusercontent.com/72501562/121781623-a36eea00-cbe0-11eb-80eb-6c7d05c5b7f3.png)  

<br> 
    
- EIFR 제어 레지스터  
  + ![image](https://user-images.githubusercontent.com/72501562/121781636-ba154100-cbe0-11eb-9750-a302136a0c0f.png)  
  + 외부 인터럽트 플래그 레지스터 **EIFR (External Interrupt Flag Register)** 는 INT7~0핀에 인터럽트 신호가 입력되어, 해당 인터럽트가 트리거 되었음을 표시하는 데 사용한다. 
  + 이 비트들은 인터럽트 처리가 시작되고 마이크로 컨트롤러가 인터럽트 벡터를 인출하여 인터럽트 서비스 루틴으로 점프하게 되면 다시 0으로 클리어 된다. 
  + 강제로 0을 클리어 하려면, 해당 비트에 1을 라이트 하면 된다. 

<br>

- EICRA 제어 레지스터 (External Interrupt Control Register A) 
  + 외부 인터럽트 INT3~0 핀으로 입력되는 신호에 대한 인터럽트 트리거 방법을 설정 
  + 모든 레벨 트리거 인터럽트와 INT3~0이 하강 또는 상승 에지 트리거 방식으로 설정 시 인터럽트가 클럭 신호와 관계 없이 비동기적으로 검출, 슬립 모드를 해제하는 수단으로 사용 가능 
  + ![image](https://user-images.githubusercontent.com/72501562/121782051-b4b8f600-cbe2-11eb-9874-ad4696c8b423.png)

|ISCn1|ISCn0|인터럽트 발생 방식|
|:--:|:--:|:--:|
|0|0|INTn 핀의 L상태 입력이 인터럽트를 트리거한다.|
|0|1|사용하지 않음(Reserved)|
|1|0|INTn 핀에 하강 에지의 신호가 입력 시 비동기적으로 트리거|
|0|1|INTn 핀에 상승 에지의 신호가 입력 시 비동기적으로 트리거|    

<br>

- EICRB 제어 레지스터 
  + 외부 인터럽트 INT7~4 핀으로 입력되는 신호에 대한 인터럽트 트리거 방법을 설정 
  + INT7~4가 에지 트리거 방식으로 설정 시, I/O 클럭이 필요하게 되므로 I/O 클럭이 차단되는 IDLE 모드 이외의 슬립모드에서는 슬립모드를 해제하는 수단으로 사용 불가 
  + ![image](https://user-images.githubusercontent.com/72501562/121782266-b46d2a80-cbe3-11eb-849d-785566fac7fc.png)  

|ISCn1|ISCn0|인터럽트 발생 방식|
|:--:|:--:|:--:|
|0|0|INTn 핀의 L상태 입력이 인터럽트를 트리거한다.|
|0|1|INTn 핀의 하강 에지 또는 상승 에지가 인터럽트를 트리거|
|1|0|INTn 핀에 하강 에지의 신호가 입력 시 비동기적으로 트리거|
|0|1|INTn 핀에 상승 에지의 신호가 입력 시 비동기적으로 트리거|  

에지 트리거로 사용되는 인터럽트 신호의 최소 신호 폭은 50ns 이상이어야함  

<br>











